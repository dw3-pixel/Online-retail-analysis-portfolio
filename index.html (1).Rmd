---
title: "Online Retail Analysis"
author: "Dorothy Worbie"
output: html_document
fontsize: 10pt
---

# 1. Data Cleaning and Preparation

--- Loading libraries - this will create a toolkit that will import the data, clean and visualize it for the analysis.

- library(readr)
- library(dplyr)
- library(lubridate)
- library(stringr)
- library(scales)
- library(ggplot2)

# Import and clean the dataset

--- Cleaning the data by removing invalid and canceled transactions,then create a new dataframe with columns for "TotalSales", with properly formatted dates, for deeper analysis .

online_retail_clean <- read_csv("Online Retail.csv", trim_ws = TRUE) %>%
  filter(Quantity > 0, UnitPrice > 0) %>%
  filter(!str_detect(InvoiceNo, "^C")) %>%
  drop_na(CustomerID) %>%
  mutate(TotalSales = Quantity * UnitPrice,
         InvoiceDate = dmy_hm(InvoiceDate))

# 2. Exploratory Data Analysis (EDA)

--- Aggregating the cleaned retail data to calculate and show the total sales revenue for each month in a new data frame called "monthly_sales". 

monthly_sales <- online_retail_clean %>%
  mutate(InvoiceMonth = floor_date(InvoiceDate, "month")) %>%
  group_by(InvoiceMonth) %>%
  summarise(MonthlyRevenue = sum(TotalSales, na.rm = TRUE)) %>%
  ungroup()
  
## Plotting

--- Creating a line graph that visualizes the monthly revenue trend from the monthly_sales data frame and making use of formats for clear and easy interprations.

ggplot(monthly_sales, aes(x = InvoiceMonth, y = MonthlyRevenue)) +
  geom_line(color = "steelblue") +
  geom_point(color = "steelblue") +
  labs(title = "Monthly Revenue Trend", x = "Month", y = "Revenue ($)") +
  theme_minimal() +
  scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
  scale_y_continuous(labels = scales::comma)

# Top Products and Countries

--- Aggregating the data by country to identify and display the top 10 countries with the highest total revenue, formatted to display in descending order.

top_10_countries <- online_retail_clean %>%
  group_by(Country) %>%
  summarise(TotalRevenue = sum(TotalSales, na.rm = TRUE)) %>%
  arrange(desc(TotalRevenue)) %>%
  head(10)

--- Aggregating the data by product to identify and show the top 10 products with the highest total revenue, displayed from highest to lowest.

top_products <- online_retail_clean %>%
  group_by(Description) %>%
  summarise(TotalRevenue = sum(TotalSales, na.rm = TRUE)) %>%
  arrange(desc(TotalRevenue)) %>%
  head(10)

### Plotting

--- Generating a horizontal barchat that visualizes the top 10 countries with the highest total revenue, in descending order, using "cord_flip".

plot_countries <- ggplot(top_10_countries, aes(x = reorder(Country, TotalRevenue), y = TotalRevenue)) +
  geom_col(fill = "darkgreen") +
  labs(title = "Top 10 Countries by Revenue", x = "Country", y = "Total Revenue") +
  coord_flip() +
  theme_minimal()

--- Generating a horizontal barchat that visualizes the top 10 products contributing the highest total revenue,in descending order.

plot_products <- ggplot(top_products, aes(x = reorder(Description, TotalRevenue), y = TotalRevenue)) +
  geom_col(fill = "steelblue") +
  labs(title = "Top 10 Products by Revenue", x = "Description", y = "Total Revenue") +
  coord_flip() +
  theme_minimal()

--- Collectively producing two distinct barchats, with one visualizing the top 10 countries and the other showing top 10 products by revenue.

plot_countries
plot_products


--- Finding the single best-selling product based on revenue for each of the top 10 countries, then store the results in new data frame - "top_product_by_country".

top_product_by_country <- online_retail_clean %>%
  filter(Country %in% top_10_countries$Country) %>%
  group_by(Country, Description) %>%
  summarise(TotalRevenue = sum(TotalSales, na.rm = TRUE)) %>%
  slice_max(order_by = TotalRevenue, n = 1) %>%
  ungroup()


--- Generating a barchat that shows the highest-revenue product from each of the top 10 countries, with the color of each bar showing which country it belongs to.

ggplot(top_product_by_country, aes(x = reorder(Description, TotalRevenue), y = TotalRevenue, fill = Country)) +
  geom_col(position = "dodge") +
  labs(title = "Top Product by Revenue in Each Top Country", x = "Product", y = "Total Revenue", fill = "Country") +
  coord_flip() +
  theme_minimal()

# 3. Customer Segmentation (RFM Analysis)

--- Calculating a sales summary for each customer, finding out their Customer Lifetime Value (CLV), Order frequency and most recent date of order and storing the result in a new dataframe called "customer_sales_summary".

customer_sales_summary <- online_retail_clean %>%
  group_by(CustomerID) %>%
  summarise(
    CLV = sum(TotalSales, na.rm = TRUE),
    OrderFrequency = n_distinct(InvoiceNo),
    Recency = max(InvoiceDate)
  ) %>%
  ungroup()

--- Calculating the Recency, Frequency and Monetary (RFM) scores for each customer,combine them into a single score and then assign each customer to a specific segment (High Value, At risk...) using the scores.

customer_rfm_score <- customer_sales_summary %>% 
  mutate(
    RecencyDays = as.numeric(as.Date("2011-12-09") - as.Date(Recency)),
    R_Score = ntile(desc(RecencyDays), 5),
    F_Score = ntile(OrderFrequency, 5),
    M_Score = ntile(CLV, 5)
  ) %>%
  mutate(RFM_Score = paste0(R_Score, F_Score, M_Score)) %>%
  mutate(Segment = case_when(
    # High Value: Recent (R=4-5), Frequent (F=4-5), and High Spend (M=4-5)
    str_detect(RFM_Score, "^[4-5][4-5][4-5]") ~ "High Value",
    # Loyal Customers: Less recent (R=3) but still frequent and high spend
    str_detect(RFM_Score, "^[3][4-5][4-5]") ~ "Loyal Customers",
    # Big Spenders: Low Recency and Frequency but high Monetary value (M=4-5)
    str_detect(RFM_Score, "^[1-2][1-3][4-5]") ~ "Big Spenders",
    # At-Risk: Not recent (R=1-2) but were frequent and high spenders in the past
    str_detect(RFM_Score, "^[1-2][4-5][4-5]") ~ "At-Risk",
    # Hibernating: Low scores across the board (R=1-2, F=1-2, M=1-2)
    str_detect(RFM_Score, "^[1-2][1-2][1-2]") ~ "Hibernating",
    TRUE ~ "Others"
  ))
  
--- Creating a clean scatter plot to show the relationship between customer Frequency and Monetary scores,using different colors to highlight Recency score.
  
ggplot(customer_rfm_score, aes(x = F_Score, y = M_Score, color = R_Score)) +
  geom_point(alpha = 0.6, size = 3) +
  labs(
    title = "RFM Analysis of Customer Segments",
    subtitle = "Frequency vs. Monetary with Recency",
    x = "Frequency Score (1-5)",
    y = "Monetary Score (1-5)",
    color = "Recency Score (1-5)"
  ) +
  theme_minimal() +
  scale_color_viridis_c()

# 4. Market Basket Analysis

--- Installing and loading the libraries to be used in finding product buying patterns to create visual maps that show relationships.

 install.packages("arules")
 install.packages("arulesViz")
- library(arules)
- library(arulesViz)

--- Finding every unique product purchased within each order, then store all the orders as a simple list of products,for deeper analysis.

transactions_list <- online_retail_clean %>%
  group_by(InvoiceNo) %>%
  summarize(items = list(unique(Description))) %>%
  pull(items)

--- Grouping the list of products by order,then converting the list into a an object(transactions),which is sparse format, required for the facilitation of the deeper analysis.

transactions_arules <- as(transactions_list, "transactions")

--- Identifying the strong rules about which products are bought together,then display the top 10 most surprising and strongest product relationships based on how much the purchase of one product increases the expected purchase of another. 

rules <- apriori(transactions_arules, parameter = list(support = 0.01, confidence = 0.5))
inspect(head(sort(rules, by = "lift"), 10))



--- Plotting a network graph by taking the top 100 product pairs that sell together better than expected, then make the graph web-based, to allow for interactivity and exploration of the connections.

top_rules <- head(sort(rules, by = "lift"), 100)
plot(top_rules, method = "graph", engine = "htmlwidget")

# 5. Dashboard Data Export

--- Combining the transformed sales data with the RFM scores and customer segments to create and save a complete dataset, for dashboarding in Tableau.

dashboard_data <- online_retail_clean %>%
  inner_join(customer_rfm_score, by = "CustomerID")

write.csv(dashboard_data, "dashboard_data.csv", row.names = FALSE)